{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blabla","title":"Blabla"},{"location":"#blabla","text":"","title":"Blabla"},{"location":"interactions/","text":"Vers la boucle principale du jeu Rappel des \u00e9pisodes pr\u00e9c\u00e9dents Programme \u00e0 t\u00e9l\u00e9charger (version 3). Rappel des notions. Introduction \u00e0 l'\u00e9diteur Interaction avec le joueur Pour demander une lettre on utilise feuille.textinput(titre,question) qui cr\u00e9e une fen\u00eatre dans laquelle l'utilisateur peut taper sa r\u00e9ponse. Les param\u00e8tres titre et question permettent de sp\u00e9cifier le titre de cette fen\u00eatre et d'\u00e9crire le texte de la question. Par exemple : lettre = feuille . textinput ( \"Proposer une lettre\" , \"Quelle lettre proposez-vous ?\" ) affichera : Tester cette instruction en l'int\u00e9grant dans le programme. Cette instruction n'accepte-t-elle qu'une lettre comme voulu dans le programme ? Pour v\u00e9rifier que le joueur propose bien une unique lettre, on \u00e9crit une fonction qui renverra la saisie de l'utilisateur seulement si elle est valide. On introduit donc ici l'instruction return ( renvoyer en fran\u00e7ais), qui permet \u00e0 une fonction de transmettre un r\u00e9sultat au reste du programme : 1 2 3 4 def demander_lettre (): lettre = feuille . textinput ( \"Proposer une lettre\" , \"Quelle lettre proposez-vous ?\" ) # On ajoutera ici la validation de la saisie return lettre Il nous reste \u00e0 valider la saisie avant de renvoyer la lettre via l'utilisation d'une instruction conditionnelle . Instruction conditionnelle L'instruction conditionnelle permet de traduire en python le traitement suivant : si la saisie est une lettre de l'alphabet alors afficher le message \"lettre accept\u00e9e\" et renvoyer cette lettre sinon afficher un avertissement et renvoyer une cha\u00eene de caract\u00e8res vide 1 2 3 4 5 6 7 8 9 10 def get_lettre (): lettre = feuille . textinput ( \"Proposer une lettre\" , \"Quelle lettre proposez-vous ?\" ) if len ( lettre ) == 1 and lettre in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" : efface_message () affiche_message ( \"Lettre accept\u00e9e\" ) return lettre else : efface_message () affiche_message ( \"Il faut saisir une lettre majuscule\" ) return \"\" Ecrire une boucle for dans votre programme permettant d'appeler get_lettre \u00e0 cinq reprises pour tester cette fonction. Boucle non born\u00e9e La boucle for , d\u00e9j\u00e0 rencontr\u00e9e permet de r\u00e9p\u00e9ter des instructions un nombre d\u00e9termin\u00e9 de fois, on parle dans ce cas, de boucles born\u00e9es . La situation ici est diff\u00e9rente, on ne conna\u00eet pas le nombre d'erreurs que va commettre le joueur avant de d\u00e9couvrir le mot. On utilise une boucle non born\u00e9e en sp\u00e9cifiant sa condition d'arr\u00eat, en fran\u00e7ais cela donne : tant que le nombre d'erreurs possibles (limit\u00e9 \u00e0 6), n'est pas atteint r\u00e9p\u00e9ter la demande d'une lettre. Ou encore en Python: nb_erreurs = 0 while nb_erreurs < 7 : lettre = get_lettre () Inclure ces lignes dans le programme du pendu et constater que la boucle est pour le moment infinie puisque la variable nb_erreurs reste \u00e0 0. Encore des instructions conditionnelles ... Il faut donc mettre \u00e0 jour l'affichage du jeu en fonction de la r\u00e9ponse du joueur : * si la lettre fait partie du mot, alors on \u00e9crit cette lettre dans la case ou les cases correspondantes ; cette t\u00e2che est r\u00e9alis\u00e9e par la fonction ecrit_lettre dont la d\u00e9finition vous est donn\u00e9e : def ecrit_lettre ( mot , lettre ): x =- 50 * len ( mot ) // 2 for l in mot : if l == lettre : crayon . penup () crayon . goto ( x + 20 , - 250 ) crayon . pendown () crayon . write ( lettre , font = ( \"Arial\" , 24 , \"bold\" ), align = \"center\" ) x += 50 sinon on incr\u00e9mente le nombre d'erreurs : nb_erreurs = 0 while nb_erreurs < 7 : lettre = get_lettre () # On teste si une lettre a bien \u00e9t\u00e9 propos\u00e9e (sinon c'est la chaine vide qui est renvoy\u00e9e) if lettre != \"\" : if lettre in MOT : ecrit_lettre ( MOT , lettre ) else : nb_erreurs += 1 Remplacer la boucle pr\u00e9c\u00e9dente par celle-ci dans le programme du pendu, et v\u00e9rifier qu'\u00e0 pr\u00e9sent la boucle se termine apr\u00e8s 7 erreurs. Dessin du pendu correspondant au nombre d'erreurs Apr\u00e8s la mise \u00e0 jour de nb_erreurs , on voudrait modifier en cons\u00e9quence le dessin du pendu. On doit donc \u00e9crire une fonction tracer_pendu qui prend en param\u00e8tre le nombre d'erreurs commises par le joueur et trace le dessin correspondant. Compl\u00e9ter la d\u00e9finition de cette fonction : def tracer_pendu ( nb ): if nb == 1 : pendu_1 () elif nb == 2 : pendu_2 () elif nb == ... : pendu_ .... ...... Remarquer l'instruction elif contraction de else if . Appel de cette fonction dans la boucle Compl\u00e9ter la boucle while en y incluant l'appel \u00e0 cette fonction lorsque le nombre d'erreurs augmente. Ce qu'il reste \u00e0 faire Le jeu commence \u00e0 prendre forme. Il nous manque encore la prise en compte de la victoire du joueur.","title":"Interactions"},{"location":"interactions/#vers-la-boucle-principale-du-jeu","text":"","title":"Vers la boucle principale du jeu"},{"location":"interactions/#rappel-des-episodes-precedents","text":"Programme \u00e0 t\u00e9l\u00e9charger (version 3). Rappel des notions. Introduction \u00e0 l'\u00e9diteur","title":"Rappel des \u00e9pisodes pr\u00e9c\u00e9dents"},{"location":"interactions/#interaction-avec-le-joueur","text":"Pour demander une lettre on utilise feuille.textinput(titre,question) qui cr\u00e9e une fen\u00eatre dans laquelle l'utilisateur peut taper sa r\u00e9ponse. Les param\u00e8tres titre et question permettent de sp\u00e9cifier le titre de cette fen\u00eatre et d'\u00e9crire le texte de la question. Par exemple : lettre = feuille . textinput ( \"Proposer une lettre\" , \"Quelle lettre proposez-vous ?\" ) affichera : Tester cette instruction en l'int\u00e9grant dans le programme. Cette instruction n'accepte-t-elle qu'une lettre comme voulu dans le programme ? Pour v\u00e9rifier que le joueur propose bien une unique lettre, on \u00e9crit une fonction qui renverra la saisie de l'utilisateur seulement si elle est valide. On introduit donc ici l'instruction return ( renvoyer en fran\u00e7ais), qui permet \u00e0 une fonction de transmettre un r\u00e9sultat au reste du programme : 1 2 3 4 def demander_lettre (): lettre = feuille . textinput ( \"Proposer une lettre\" , \"Quelle lettre proposez-vous ?\" ) # On ajoutera ici la validation de la saisie return lettre Il nous reste \u00e0 valider la saisie avant de renvoyer la lettre via l'utilisation d'une instruction conditionnelle .","title":"Interaction avec le joueur"},{"location":"interactions/#instruction-conditionnelle","text":"L'instruction conditionnelle permet de traduire en python le traitement suivant : si la saisie est une lettre de l'alphabet alors afficher le message \"lettre accept\u00e9e\" et renvoyer cette lettre sinon afficher un avertissement et renvoyer une cha\u00eene de caract\u00e8res vide 1 2 3 4 5 6 7 8 9 10 def get_lettre (): lettre = feuille . textinput ( \"Proposer une lettre\" , \"Quelle lettre proposez-vous ?\" ) if len ( lettre ) == 1 and lettre in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" : efface_message () affiche_message ( \"Lettre accept\u00e9e\" ) return lettre else : efface_message () affiche_message ( \"Il faut saisir une lettre majuscule\" ) return \"\" Ecrire une boucle for dans votre programme permettant d'appeler get_lettre \u00e0 cinq reprises pour tester cette fonction.","title":"Instruction conditionnelle"},{"location":"interactions/#boucle-non-bornee","text":"La boucle for , d\u00e9j\u00e0 rencontr\u00e9e permet de r\u00e9p\u00e9ter des instructions un nombre d\u00e9termin\u00e9 de fois, on parle dans ce cas, de boucles born\u00e9es . La situation ici est diff\u00e9rente, on ne conna\u00eet pas le nombre d'erreurs que va commettre le joueur avant de d\u00e9couvrir le mot. On utilise une boucle non born\u00e9e en sp\u00e9cifiant sa condition d'arr\u00eat, en fran\u00e7ais cela donne : tant que le nombre d'erreurs possibles (limit\u00e9 \u00e0 6), n'est pas atteint r\u00e9p\u00e9ter la demande d'une lettre. Ou encore en Python: nb_erreurs = 0 while nb_erreurs < 7 : lettre = get_lettre () Inclure ces lignes dans le programme du pendu et constater que la boucle est pour le moment infinie puisque la variable nb_erreurs reste \u00e0 0.","title":"Boucle non born\u00e9e"},{"location":"interactions/#encore-des-instructions-conditionnelles","text":"Il faut donc mettre \u00e0 jour l'affichage du jeu en fonction de la r\u00e9ponse du joueur : * si la lettre fait partie du mot, alors on \u00e9crit cette lettre dans la case ou les cases correspondantes ; cette t\u00e2che est r\u00e9alis\u00e9e par la fonction ecrit_lettre dont la d\u00e9finition vous est donn\u00e9e : def ecrit_lettre ( mot , lettre ): x =- 50 * len ( mot ) // 2 for l in mot : if l == lettre : crayon . penup () crayon . goto ( x + 20 , - 250 ) crayon . pendown () crayon . write ( lettre , font = ( \"Arial\" , 24 , \"bold\" ), align = \"center\" ) x += 50 sinon on incr\u00e9mente le nombre d'erreurs : nb_erreurs = 0 while nb_erreurs < 7 : lettre = get_lettre () # On teste si une lettre a bien \u00e9t\u00e9 propos\u00e9e (sinon c'est la chaine vide qui est renvoy\u00e9e) if lettre != \"\" : if lettre in MOT : ecrit_lettre ( MOT , lettre ) else : nb_erreurs += 1 Remplacer la boucle pr\u00e9c\u00e9dente par celle-ci dans le programme du pendu, et v\u00e9rifier qu'\u00e0 pr\u00e9sent la boucle se termine apr\u00e8s 7 erreurs.","title":"Encore des instructions conditionnelles ..."},{"location":"interactions/#dessin-du-pendu-correspondant-au-nombre-derreurs","text":"Apr\u00e8s la mise \u00e0 jour de nb_erreurs , on voudrait modifier en cons\u00e9quence le dessin du pendu. On doit donc \u00e9crire une fonction tracer_pendu qui prend en param\u00e8tre le nombre d'erreurs commises par le joueur et trace le dessin correspondant. Compl\u00e9ter la d\u00e9finition de cette fonction : def tracer_pendu ( nb ): if nb == 1 : pendu_1 () elif nb == 2 : pendu_2 () elif nb == ... : pendu_ .... ...... Remarquer l'instruction elif contraction de else if .","title":"Dessin du pendu correspondant au nombre d'erreurs"},{"location":"interactions/#appel-de-cette-fonction-dans-la-boucle","text":"Compl\u00e9ter la boucle while en y incluant l'appel \u00e0 cette fonction lorsque le nombre d'erreurs augmente.","title":"Appel de cette fonction dans la boucle"},{"location":"interactions/#ce-quil-reste-a-faire","text":"Le jeu commence \u00e0 prendre forme. Il nous manque encore la prise en compte de la victoire du joueur.","title":"Ce qu'il reste \u00e0 faire"},{"location":"jeu_complet/","text":"Finalisation du jeu Rappel des \u00e9pisodes pr\u00e9c\u00e9dents Programme \u00e0 t\u00e9l\u00e9charger (version 4). Rappel des notions. Fin du jeu lorsque le joueur gagne Pour le moment notre boucle de jeu s'arr\u00eate lorsque le joueur a commis 7 erreurs : nb_erreurs = 0 while nb_erreurs < 7 : # suite de notre boucle On doit aussi tester la victoire du joueur et sortir de la boucle lorsqu'elle survient. On introduit la variable bool\u00e9enne trouve qui vaut True lorsque le mot a \u00e9t\u00e9 enti\u00e8rement trouv\u00e9 et False sinon. nb_erreurs = 0 trouve = False while nb_erreurs < 7 and not trouve : # suite de notre boucle Comme pour le nombre d'erreurs, la mise \u00e0 jour de la variable trouve s'effectue apr\u00e8s chaque lettre propos\u00e9e via une fonction verifie que nous \u00e9crirons par la suite. On redonne ci-dessous la boucle principale \u00e0 compl\u00e9ter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 nb_erreurs = 0 trouve = False deja_proposees = ... while nb_erreurs < 7 and not trouve : lettre = get_lettre () if lettre != \"\" : barre_lettre ( lettre ) deja_proposees = ... if lettre in MOT : ecrit_lettre ( MOT , lettre ) ... = verifie ( MOT , deja_proposees ) else : nb_erreurs += 1 tracer_pendu ( nb_erreurs ) Ligne 3 : initialiser deja_proposees avec la cha\u00eene de caract\u00e8res vide Ligne 8 : ajouter la lettre \u00e0 celles d\u00e9j\u00e0 propos\u00e9es Ligne 11 : compl\u00e9ter avec le nom de la variable \u00e0 mettre \u00e0 jour La fonction verifie La mise \u00e0 jour consiste \u00e0 mettre la variable \u00e0 True lorsque toutes les lettres du mot font partie des lettres d\u00e9j\u00e0 propos\u00e9es qu'il nous faut donc m\u00e9moriser.","title":"Premi\u00e8re version"},{"location":"jeu_complet/#finalisation-du-jeu","text":"","title":"Finalisation du jeu"},{"location":"jeu_complet/#rappel-des-episodes-precedents","text":"Programme \u00e0 t\u00e9l\u00e9charger (version 4). Rappel des notions.","title":"Rappel des \u00e9pisodes pr\u00e9c\u00e9dents"},{"location":"jeu_complet/#fin-du-jeu-lorsque-le-joueur-gagne","text":"Pour le moment notre boucle de jeu s'arr\u00eate lorsque le joueur a commis 7 erreurs : nb_erreurs = 0 while nb_erreurs < 7 : # suite de notre boucle On doit aussi tester la victoire du joueur et sortir de la boucle lorsqu'elle survient. On introduit la variable bool\u00e9enne trouve qui vaut True lorsque le mot a \u00e9t\u00e9 enti\u00e8rement trouv\u00e9 et False sinon. nb_erreurs = 0 trouve = False while nb_erreurs < 7 and not trouve : # suite de notre boucle Comme pour le nombre d'erreurs, la mise \u00e0 jour de la variable trouve s'effectue apr\u00e8s chaque lettre propos\u00e9e via une fonction verifie que nous \u00e9crirons par la suite. On redonne ci-dessous la boucle principale \u00e0 compl\u00e9ter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 nb_erreurs = 0 trouve = False deja_proposees = ... while nb_erreurs < 7 and not trouve : lettre = get_lettre () if lettre != \"\" : barre_lettre ( lettre ) deja_proposees = ... if lettre in MOT : ecrit_lettre ( MOT , lettre ) ... = verifie ( MOT , deja_proposees ) else : nb_erreurs += 1 tracer_pendu ( nb_erreurs ) Ligne 3 : initialiser deja_proposees avec la cha\u00eene de caract\u00e8res vide Ligne 8 : ajouter la lettre \u00e0 celles d\u00e9j\u00e0 propos\u00e9es Ligne 11 : compl\u00e9ter avec le nom de la variable \u00e0 mettre \u00e0 jour","title":"Fin du jeu lorsque le joueur gagne"},{"location":"jeu_complet/#la-fonction-verifie","text":"La mise \u00e0 jour consiste \u00e0 mettre la variable \u00e0 True lorsque toutes les lettres du mot font partie des lettres d\u00e9j\u00e0 propos\u00e9es qu'il nous faut donc m\u00e9moriser.","title":"La fonction verifie"}]}